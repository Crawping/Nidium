# Fix various stuff not supported by clang
# See 
#	- https://chromium.googlesource.com/skia/+/ea13afff6e46d8a969611cdd56c996bfb05a27c1
# 	- https://chromium.googlesource.com/skia/+/81cc04d0a6f1d841da75c30e3ff3cc2437d35935
--- skia/src/opts/memset16_neon.S
+++ skia/src/opts/memset16_neon.S
@@ -15,6 +15,8 @@
 
 ***************************************************************************/
 
+        .syntax unified
+
         .code 32
         .fpu neon
         .align 4
@@ -70,7 +72,7 @@
         strcs           r1, [r0], #4
         strcs           r1, [r0], #4
         lsls            r12, r12, #2
-        strcsh          r1, [r0], #2
+        strhcs          r1, [r0], #2
 memset_route:
         /*
          * Decide where to route for the maximum copy sizes.  Note that we

--- skia/src/opts/SkBlitRow_opts_arm_neon.cpp
+++ skia/src/opts/SkBlitRow_opts_arm_neon.cpp
@@ -299,7 +299,7 @@
 
                       "11:                                        \n\t"
                       // unzips achieve the same as a vld4 operation
-                      "vuzpq.u16  q0, q1                      \n\t"
+                      "vuzp.u16   q0, q1                      \n\t"
                       "vuzp.u8    d0, d1                      \n\t"
                       "vuzp.u8    d2, d3                      \n\t"
                       // expand 0565 q12 to 8888 {d4-d7}

--- skia/src/opts/memset16_neon.S
+++ skia/src/opts/memset16_neon.S
@@ -21,7 +21,6 @@
         .fpu neon
         .align 4
         .globl memset16_neon
-        .func
 
 memset16_neon:
         cmp             r2, #0
@@ -141,5 +140,4 @@
         pop             {r0}
         bx              lr
 
-        .endfunc
         .end

--- skia/src/opts/memset32_neon.S
+++ skia/src/opts/memset32_neon.S
@@ -9,7 +9,6 @@
 	.fpu neon
 	.align 4
 	.globl	memset32_neon
-	.func
 
 	/* r0 = buffer, r1 = value, r2 = times to write */
 memset32_neon:
@@ -109,5 +108,4 @@
 	str		r1, [r0, #0]
 	bx		lr
 
-	.endfunc
 	.end


# See https://llvm.org/bugs/show_bug.cgi?id=18505
--- skia/gyp/opts.gyp
+++ skia/gyp/opts.gyp
@@ -69,7 +69,7 @@
           ],
           'cflags': [
             '-fomit-frame-pointer',
-            '-mno-apcs-frame',
+#'-mno-apcs-frame',
           ],
           'variables': {
             'arm_neon_optional%': '<(arm_neon_optional>',


# Unsupported option for clang
--- skia/gyp/common_conditions.gypi
+++ skia/gyp/common_conditions.gypi
@@ -605,7 +610,7 @@
           '-llog',
         ],
         'cflags': [
-          '-fuse-ld=gold',
+#'-fuse-ld=gold',
         ],
         'conditions': [
           [ 'skia_android_framework', {


# Switch to clang
--- skia/platform_tools/android/bin/utils/setup_toolchain.sh
+++ skia/platform_tools/android/bin/utils/setup_toolchain.sh
@@ -68,20 +68,20 @@ if [ -z "$ANDROID_TOOLCHAIN" ]; then
   fi
 fi
 
-GCC=$(command ls $ANDROID_TOOLCHAIN/*-gcc | head -n1)
+GCC=$(command ls $ANDROID_TOOLCHAIN/*-clang| head -n1)
 if [ -z "$GCC" ]; then
   echo "ERROR: Could not find Android cross-compiler in: $ANDROID_TOOLCHAIN"
   return 1
 fi
 
 # Remove the '-gcc' at the end to get the full toolchain prefix
-ANDROID_TOOLCHAIN_PREFIX=${GCC%%-gcc}
+ANDROID_TOOLCHAIN_PREFIX=${GCC%%-clang}
 
 CCACHE=${ANDROID_MAKE_CCACHE-$(which ccache || true)}
 
-exportVar CC "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-gcc"
-exportVar CXX "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-g++"
-exportVar LINK "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-gcc"
+exportVar CC "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-clang"
+exportVar CXX "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-clang++"
+exportVar LINK "$CCACHE $ANDROID_TOOLCHAIN_PREFIX-clang"
